#!/usr/bin/env python3
"""
Test script for Advanced Malware Classification System
====================================================

Tests the deep learning models for malware family identification,
behavioral analysis neural networks, and similarity analysis using
embedding models and clustering.

Author: REVENG Project - AI Enhancement Module
Version: 1.0
"""

import sys
import os
import logging
from pathlib import Path

# Add tools directory to path
sys.path.insert(0, str(Path(__file__).parent / "tools"))

try:
    from ml_malware_classifier import MLMalwareClassifier, MalwareFeatures
    from ai_enhanced_data_models import MalwareClassification, BehavioralPattern
except ImportError as e:
    print(f"Import error: {e}")
    print("Please ensure all required modules are available")
    sys.exit(1)

def setup_logging():
    """Setup logging for tests"""
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )

def test_basic_classification():
    """Test basic malware classification functionality"""
    print("=" * 60)
    print("Testing Basic Malware Classification")
    print("=" * 60)
    
    classifier = MLMalwareClassifier()
    
    # Test sample data
    test_samples = [
        {
            'file_path': 'test_trojan.exe',
            'strings': [
                'http://malicious-c2.com', 'CreateProcess', 'RegSetValue',
                'InternetConnect', 'keylogger', 'password'
            ],
            'apis': [
                'CreateProcess', 'RegSetValue', 'InternetConnect', 'socket',
                'GetAsyncKeyState', 'SetWindowsHook', 'WriteFile'
            ],
            'code_analysis': {
                'function_count': 85,
                'import_count': 25,
                'basic_block_count': 750,
                'call_graph_complexity': 0.8
            },
            'expected_family': 'trojan'
        },
        {
            'file_path': 'test_ransomware.exe',
            'strings': [
                'bitcoin', 'encrypt', 'decrypt', 'ransom', 'payment',
                'CryptEncrypt', 'files encrypted'
            ],
            'apis': [
                'CryptAcquireContext', 'CryptEncrypt', 'CreateFile',
                'WriteFile', 'FindFirstFile', 'FindNextFile'
            ],
            'code_analysis': {
                'function_count': 45,
                'import_count': 15,
                'basic_block_count': 400,
                'call_graph_complexity': 0.6
            },
            'expected_family': 'ransomware'
        },
        {
            'file_path': 'test_spyware.exe',
            'strings': [
                'screenshot', 'microphone', 'camera', 'steal',
                'credentials', 'browser', 'cookies'
            ],
            'apis': [
                'BitBlt', 'GetDC', 'waveInOpen', 'capCreateCaptureWindow',
                'InternetOpen', 'HttpSendRequest'
            ],
            'code_analysis': {
                'function_count': 65,
                'import_count': 30,
                'basic_block_count': 600,
                'call_graph_complexity': 0.7
            },
            'expected_family': 'spyware'
        }
    ]
    
    results = []
    
    for i, sample in enumerate(test_samples):
        print(f"\nTesting sample {i+1}: {sample['file_path']}")
        
        classification = classifier.classify_malware(
            sample['file_path'],
            sample['strings'],
            sample['apis'],
            sample['code_analysis']
        )
        
        results.append(classification)
        
        print(f"  Predicted Family: {classification.family}")
        print(f"  Confidence: {classification.confidence:.3f}")
        print(f"  Is Malware: {classification.is_malware}")
        print(f"  Method: {classification.classification_method}")
        print(f"  Anomaly Score: {classification.anomaly_score:.3f}")
        print(f"  Behavioral Patterns: {len(classification.behavioral_patterns)}")
        
        # Show behavioral patterns
        for pattern in classification.behavioral_patterns[:3]:  # Show first 3
            print(f"    - {pattern.type}: {pattern.description}")
    
    return results

def test_similarity_analysis():
    """Test similarity analysis and clustering"""
    print("\n" + "=" * 60)
    print("Testing Similarity Analysis and Clustering")
    print("=" * 60)
    
    classifier = MLMalwareClassifier()
    
    # Create test samples with different characteristics
    samples = [
        # Trojan-like samples
        ('trojan1.exe', 
         ['http://evil.com', 'keylogger', 'password'], 
         ['GetAsyncKeyState', 'SetWindowsHook', 'InternetConnect'],
         {'function_count': 50, 'import_count': 20}),
        
        ('trojan2.exe', 
         ['http://malware.net', 'steal', 'credentials'], 
         ['GetAsyncKeyState', 'InternetOpen', 'WriteFile'],
         {'function_count': 55, 'import_count': 22}),
        
        # Ransomware-like samples
        ('ransom1.exe', 
         ['encrypt', 'bitcoin', 'payment'], 
         ['CryptEncrypt', 'FindFirstFile', 'CreateFile'],
         {'function_count': 40, 'import_count': 15}),
        
        ('ransom2.exe', 
         ['decrypt', 'ransom', 'files'], 
         ['CryptAcquireContext', 'FindNextFile', 'WriteFile'],
         {'function_count': 42, 'import_count': 16}),
        
        # Benign-like sample
        ('benign.exe', 
         ['help', 'version', 'config'], 
         ['CreateFile', 'ReadFile', 'WriteFile'],
         {'function_count': 25, 'import_count': 10})
    ]
    
    print(f"Analyzing {len(samples)} samples...")
    
    # Test similarity matrix
    similarity_matrix = classifier.get_malware_similarity_matrix(samples)
    
    if similarity_matrix.size > 0:
        print("\nSimilarity Matrix:")
        print("Samples:", [s[0] for s in samples])
        for i, row in enumerate(similarity_matrix):
            print(f"{samples[i][0]:12} {[f'{val:.3f}' for val in row]}")
        
        # Find most similar pairs
        print("\nMost similar pairs:")
        for i in range(len(samples)):
            for j in range(i+1, len(samples)):
                similarity = similarity_matrix[i][j]
                if similarity > 0.7:  # High similarity threshold
                    print(f"  {samples[i][0]} <-> {samples[j][0]}: {similarity:.3f}")
    
    # Test clustering
    clustering_result = classifier.cluster_malware_samples(samples, n_clusters=3)
    
    if clustering_result:
        print(f"\nClustering Results:")
        print(f"  Number of clusters: {clustering_result.get('num_clusters', 0)}")
        print(f"  Noise points: {clustering_result.get('noise_points', 0)}")
        
        for cluster_name, cluster_info in clustering_result.get('clusters', {}).items():
            print(f"  {cluster_name}: {cluster_info['samples']}")

def test_deep_learning_features():
    """Test deep learning specific features"""
    print("\n" + "=" * 60)
    print("Testing Deep Learning Features")
    print("=" * 60)
    
    try:
        import torch
        print("PyTorch is available - testing deep learning features")
        
        classifier = MLMalwareClassifier()
        
        # Test if deep models are initialized
        if classifier.deep_models:
            print(f"Deep models initialized: {list(classifier.deep_models.keys())}")
            
            # Test feature extraction and embedding
            test_features = [0.5, 7.2, 3, 15, 8, 100, 2, 1, 0, 5, 3, 2, 4, 1, 2, 3, 10, 5, 8, 12, 50, 200, 0.6, 0, 1, 0]
            
            if 'embedding_model' in classifier.deep_models:
                model = classifier.deep_models['embedding_model']
                features_tensor = torch.FloatTensor([test_features]).to(classifier.device)
                embedding = model.get_embedding(features_tensor)
                print(f"Generated embedding shape: {embedding.shape}")
                print(f"Embedding norm: {torch.norm(embedding).item():.3f}")
        else:
            print("Deep models not initialized - using traditional ML only")
            
    except ImportError:
        print("PyTorch not available - deep learning features disabled")

def test_training_simulation():
    """Simulate training process with synthetic data"""
    print("\n" + "=" * 60)
    print("Testing Training Process (Simulation)")
    print("=" * 60)
    
    classifier = MLMalwareClassifier()
    
    # Create synthetic training data
    training_samples = []
    
    # Generate samples for different families
    families = ['trojan', 'ransomware', 'spyware', 'adware', 'benign']
    
    for family in families:
        for i in range(5):  # 5 samples per family
            if family == 'trojan':
                strings = ['keylogger', 'password', 'steal', 'http://evil.com']
                apis = ['GetAsyncKeyState', 'SetWindowsHook', 'InternetConnect']
            elif family == 'ransomware':
                strings = ['encrypt', 'decrypt', 'bitcoin', 'ransom']
                apis = ['CryptEncrypt', 'FindFirstFile', 'CreateFile']
            elif family == 'spyware':
                strings = ['screenshot', 'microphone', 'spy', 'monitor']
                apis = ['BitBlt', 'GetDC', 'waveInOpen']
            elif family == 'adware':
                strings = ['advertisement', 'popup', 'click', 'revenue']
                apis = ['InternetOpen', 'HttpSendRequest', 'CreateWindow']
            else:  # benign
                strings = ['help', 'version', 'config', 'settings']
                apis = ['CreateFile', 'ReadFile', 'WriteFile']
            
            code_analysis = {
                'function_count': 30 + i * 5,
                'import_count': 10 + i * 2,
                'basic_block_count': 200 + i * 50,
                'call_graph_complexity': 0.3 + i * 0.1
            }
            
            training_samples.append((
                f'{family}_{i}.exe',
                family,
                strings,
                apis,
                code_analysis
            ))
    
    print(f"Created {len(training_samples)} synthetic training samples")
    print(f"Families: {families}")
    
    # Note: We don't actually train here to avoid long execution times
    # In a real scenario, you would call:
    # success = classifier.train_classifier(training_samples)
    # print(f"Training successful: {success}")
    
    print("Training simulation completed (actual training skipped for demo)")

def main():
    """Main test function"""
    setup_logging()
    
    print("Advanced Malware Classification System - Test Suite")
    print("=" * 60)
    
    try:
        # Run tests
        test_basic_classification()
        test_similarity_analysis()
        test_deep_learning_features()
        test_training_simulation()
        
        print("\n" + "=" * 60)
        print("All tests completed successfully!")
        print("=" * 60)
        
    except Exception as e:
        print(f"\nTest failed with error: {e}")
        import traceback
        traceback.print_exc()
        return 1
    
    return 0

if __name__ == "__main__":
    exit_code = main()
    sys.exit(exit_code)