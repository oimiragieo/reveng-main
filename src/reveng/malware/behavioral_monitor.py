"""
Behavioral Monitoring for REVENG

Advanced behavioral monitoring and analysis for malware detection.
"""

import os
import sys
import time
import json
import subprocess
import threading
from pathlib import Path
from typing import Dict, Any, List, Optional, Tuple, Set
from dataclasses import dataclass
from enum import Enum

from ..core.errors import REVENGError, AnalysisFailureError, create_error_context
from ..core.logger import get_logger

logger = get_logger(__name__)

class BehaviorType(Enum):
    """Behavior types"""
    FILE_OPERATION = "file_operation"
    REGISTRY_OPERATION = "registry_operation"
    NETWORK_OPERATION = "network_operation"
    PROCESS_OPERATION = "process_operation"
    MEMORY_OPERATION = "memory_operation"
    SYSTEM_OPERATION = "system_operation"
    CRYPTO_OPERATION = "crypto_operation"
    ANTI_ANALYSIS = "anti_analysis"

class ThreatLevel(Enum):
    """Threat levels"""
    MINIMAL = "minimal"
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"

@dataclass
class BehaviorEvent:
    """Behavioral event"""
    timestamp: float
    behavior_type: BehaviorType
    operation: str
    target: str
    parameters: Dict[str, Any] = None
    threat_level: ThreatLevel = ThreatLevel.MINIMAL
    description: str = ""
    process_id: Optional[int] = None
    thread_id: Optional[int] = None

    def __post_init__(self):
        if self.parameters is None:
            self.parameters = {}

@dataclass
class BehavioralProfile:
    """Behavioral profile"""
    binary_path: str
    analysis_duration: float
    total_events: int
    behavior_types: Dict[BehaviorType, int] = None
    threat_indicators: List[str] = None
    suspicious_operations: List[BehaviorEvent] = None
    network_connections: List[Dict[str, Any]] = None
    file_operations: List[Dict[str, Any]] = None
    registry_operations: List[Dict[str, Any]] = None
    process_operations: List[Dict[str, Any]] = None
    risk_score: float = 0.0
    threat_level: ThreatLevel = ThreatLevel.MINIMAL

    def __post_init__(self):
        if self.behavior_types is None:
            self.behavior_types = {}
        if self.threat_indicators is None:
            self.threat_indicators = []
        if self.suspicious_operations is None:
            self.suspicious_operations = []
        if self.network_connections is None:
            self.network_connections = []
        if self.file_operations is None:
            self.file_operations = []
        if self.registry_operations is None:
            self.registry_operations = []
        if self.process_operations is None:
            self.process_operations = []

class BehavioralMonitor:
    """Advanced behavioral monitoring system"""

    def __init__(self):
        self.logger = get_logger(__name__)
        self.monitoring = False
        self.events: List[BehaviorEvent] = []
        self.monitor_thread: Optional[threading.Thread] = None
        self.start_time: float = 0.0

        # Behavior patterns
        self.suspicious_patterns = {
            "file_operations": [
                "CreateFile", "WriteFile", "DeleteFile", "MoveFile", "CopyFile",
                "FindFirstFile", "FindNextFile", "GetFileAttributes", "SetFileAttributes"
            ],
            "registry_operations": [
                "RegCreateKey", "RegOpenKey", "RegSetValue", "RegDeleteValue",
                "RegQueryValue", "RegEnumKey", "RegEnumValue"
            ],
            "network_operations": [
                "socket", "connect", "send", "recv", "bind", "listen", "accept",
                "WSAStartup", "InternetOpen", "HttpSendRequest", "URLDownloadToFile"
            ],
            "process_operations": [
                "CreateProcess", "CreateProcessAsUser", "OpenProcess", "TerminateProcess",
                "CreateThread", "CreateRemoteThread", "ResumeThread", "SuspendThread"
            ],
            "memory_operations": [
                "VirtualAlloc", "VirtualFree", "VirtualProtect", "ReadProcessMemory",
                "WriteProcessMemory", "HeapAlloc", "HeapFree", "GlobalAlloc", "LocalAlloc"
            ],
            "system_operations": [
                "AdjustTokenPrivileges", "OpenProcessToken", "SetTokenInformation",
                "CreateService", "StartService", "ControlService", "DeleteService"
            ],
            "crypto_operations": [
                "CryptAcquireContext", "CryptCreateHash", "CryptHashData",
                "CryptEncrypt", "CryptDecrypt", "CryptDeriveKey", "CryptGenKey"
            ],
            "anti_analysis": [
                "IsDebuggerPresent", "CheckRemoteDebuggerPresent", "OutputDebugString",
                "GetTickCount", "QueryPerformanceCounter", "GetSystemTime"
            ]
        }

        # Threat indicators
        self.threat_indicators = {
            "persistence": [
                "RegSetValue", "RegCreateKey", "CreateService", "StartService"
            ],
            "data_exfiltration": [
                "socket", "connect", "send", "recv", "InternetOpen", "HttpSendRequest"
            ],
            "process_injection": [
                "CreateRemoteThread", "WriteProcessMemory", "VirtualAllocEx", "OpenProcess"
            ],
            "privilege_escalation": [
                "AdjustTokenPrivileges", "OpenProcessToken", "SetTokenInformation"
            ],
            "anti_analysis": [
                "IsDebuggerPresent", "CheckRemoteDebuggerPresent", "OutputDebugString"
            ],
            "file_encryption": [
                "CryptEncrypt", "CryptDecrypt", "CryptCreateHash", "CryptHashData"
            ]
        }

    def start_monitoring(self, binary_path: str, duration: int = 300) -> bool:
        """Start behavioral monitoring"""

        try:
            if self.monitoring:
                self.logger.warning("Monitoring already in progress")
                return False

            if not Path(binary_path).exists():
                raise AnalysisFailureError(
                    "behavioral_monitoring",
                    binary_path,
                    details="Binary file not found"
                )

            self.logger.info(f"Starting behavioral monitoring for: {binary_path}")

            # Initialize monitoring
            self.monitoring = True
            self.events = []
            self.start_time = time.time()

            # Start monitoring thread
            self.monitor_thread = threading.Thread(
                target=self._monitor_behavior,
                args=(binary_path, duration)
            )
            self.monitor_thread.daemon = True
            self.monitor_thread.start()

            return True

        except Exception as e:
            self.logger.error(f"Failed to start behavioral monitoring: {e}")
            return False

    def stop_monitoring(self) -> BehavioralProfile:
        """Stop monitoring and return behavioral profile"""

        try:
            if not self.monitoring:
                self.logger.warning("No monitoring in progress")
                return None

            self.logger.info("Stopping behavioral monitoring")

            # Stop monitoring
            self.monitoring = False

            # Wait for monitoring thread to finish
            if self.monitor_thread and self.monitor_thread.is_alive():
                self.monitor_thread.join(timeout=5.0)

            # Create behavioral profile
            profile = self._create_behavioral_profile()

            self.logger.info(f"Behavioral monitoring completed: {len(self.events)} events captured")
            return profile

        except Exception as e:
            self.logger.error(f"Failed to stop behavioral monitoring: {e}")
            return None

    def _monitor_behavior(self, binary_path: str, duration: int):
        """Monitor behavioral patterns"""

        try:
            end_time = time.time() + duration

            while self.monitoring and time.time() < end_time:
                # Monitor file operations
                self._monitor_file_operations()

                # Monitor registry operations
                self._monitor_registry_operations()

                # Monitor network operations
                self._monitor_network_operations()

                # Monitor process operations
                self._monitor_process_operations()

                # Monitor memory operations
                self._monitor_memory_operations()

                # Monitor system operations
                self._monitor_system_operations()

                # Monitor crypto operations
                self._monitor_crypto_operations()

                # Monitor anti-analysis techniques
                self._monitor_anti_analysis()

                # Sleep between monitoring cycles
                time.sleep(1.0)

        except Exception as e:
            self.logger.error(f"Behavioral monitoring failed: {e}")
        finally:
            self.monitoring = False

    def _monitor_file_operations(self):
        """Monitor file system operations"""

        try:
            # This is a simplified implementation
            # In a real implementation, you would use API hooks or system monitoring tools

            # Check for file operations using system tools
            result = subprocess.run(
                ["powershell", "-Command", "Get-Process | Where-Object {$_.ProcessName -like '*'} | Select-Object ProcessName, Id"],
                capture_output=True,
                text=True,
                timeout=5
            )

            if result.returncode == 0:
                # Parse process information
                lines = result.stdout.strip().split('\n')
                for line in lines[2:]:  # Skip header lines
                    if line.strip():
                        parts = line.split()
                        if len(parts) >= 2:
                            process_name = parts[0]
                            process_id = parts[1]

                            # Check for suspicious file operations
                            if any(pattern in process_name.lower() for pattern in ["explorer", "notepad", "cmd"]):
                                event = BehaviorEvent(
                                    timestamp=time.time(),
                                    behavior_type=BehaviorType.FILE_OPERATION,
                                    operation="FileAccess",
                                    target=process_name,
                                    process_id=int(process_id),
                                    threat_level=ThreatLevel.LOW,
                                    description=f"File operation by {process_name}"
                                )
                                self.events.append(event)

        except Exception as e:
            self.logger.debug(f"File operation monitoring failed: {e}")

    def _monitor_registry_operations(self):
        """Monitor registry operations"""

        try:
            # This is a simplified implementation
            # In a real implementation, you would use registry monitoring tools

            # Check for registry operations
            result = subprocess.run(
                ["reg", "query", "HKEY_CURRENT_USER\\Software", "/s"],
                capture_output=True,
                text=True,
                timeout=5
            )

            if result.returncode == 0:
                # Parse registry information
                lines = result.stdout.strip().split('\n')
                for line in lines:
                    if line.strip() and "HKEY_" in line:
                        event = BehaviorEvent(
                            timestamp=time.time(),
                            behavior_type=BehaviorType.REGISTRY_OPERATION,
                            operation="RegistryAccess",
                            target=line.strip(),
                            threat_level=ThreatLevel.LOW,
                            description=f"Registry access: {line.strip()}"
                        )
                        self.events.append(event)

        except Exception as e:
            self.logger.debug(f"Registry operation monitoring failed: {e}")

    def _monitor_network_operations(self):
        """Monitor network operations"""

        try:
            # This is a simplified implementation
            # In a real implementation, you would use network monitoring tools

            # Check for network connections
            result = subprocess.run(
                ["netstat", "-an"],
                capture_output=True,
                text=True,
                timeout=5
            )

            if result.returncode == 0:
                # Parse network connections
                lines = result.stdout.strip().split('\n')
                for line in lines:
                    if "ESTABLISHED" in line or "LISTENING" in line:
                        event = BehaviorEvent(
                            timestamp=time.time(),
                            behavior_type=BehaviorType.NETWORK_OPERATION,
                            operation="NetworkConnection",
                            target=line.strip(),
                            threat_level=ThreatLevel.MEDIUM,
                            description=f"Network connection: {line.strip()}"
                        )
                        self.events.append(event)

        except Exception as e:
            self.logger.debug(f"Network operation monitoring failed: {e}")

    def _monitor_process_operations(self):
        """Monitor process operations"""

        try:
            # This is a simplified implementation
            # In a real implementation, you would use process monitoring tools

            # Check for process creation
            result = subprocess.run(
                ["tasklist", "/fo", "csv"],
                capture_output=True,
                text=True,
                timeout=5
            )

            if result.returncode == 0:
                # Parse process information
                lines = result.stdout.strip().split('\n')
                for line in lines[1:]:  # Skip header
                    if line.strip():
                        parts = line.split(',')
                        if len(parts) >= 2:
                            process_name = parts[0].strip('"')
                            process_id = parts[1].strip('"')

                            # Check for suspicious processes
                            if any(pattern in process_name.lower() for pattern in ["cmd", "powershell", "wscript", "cscript"]):
                                event = BehaviorEvent(
                                    timestamp=time.time(),
                                    behavior_type=BehaviorType.PROCESS_OPERATION,
                                    operation="ProcessCreation",
                                    target=process_name,
                                    process_id=int(process_id),
                                    threat_level=ThreatLevel.MEDIUM,
                                    description=f"Suspicious process: {process_name}"
                                )
                                self.events.append(event)

        except Exception as e:
            self.logger.debug(f"Process operation monitoring failed: {e}")

    def _monitor_memory_operations(self):
        """Monitor memory operations"""

        try:
            # This is a simplified implementation
            # In a real implementation, you would use memory monitoring tools

            # Check for memory usage
            result = subprocess.run(
                ["wmic", "process", "get", "name,processid,workingsetsize"],
                capture_output=True,
                text=True,
                timeout=5
            )

            if result.returncode == 0:
                # Parse memory information
                lines = result.stdout.strip().split('\n')
                for line in lines[1:]:  # Skip header
                    if line.strip():
                        parts = line.split()
                        if len(parts) >= 3:
                            process_name = parts[0]
                            process_id = parts[1]
                            memory_size = parts[2]

                            # Check for high memory usage
                            try:
                                memory_mb = int(memory_size) / (1024 * 1024)
                                if memory_mb > 100:  # More than 100MB
                                    event = BehaviorEvent(
                                        timestamp=time.time(),
                                        behavior_type=BehaviorType.MEMORY_OPERATION,
                                        operation="HighMemoryUsage",
                                        target=process_name,
                                        process_id=int(process_id),
                                        threat_level=ThreatLevel.LOW,
                                        description=f"High memory usage: {memory_mb:.2f}MB"
                                    )
                                    self.events.append(event)
                            except ValueError:
                                pass

        except Exception as e:
            self.logger.debug(f"Memory operation monitoring failed: {e}")

    def _monitor_system_operations(self):
        """Monitor system operations"""

        try:
            # This is a simplified implementation
            # In a real implementation, you would use system monitoring tools

            # Check for system services
            result = subprocess.run(
                ["sc", "query"],
                capture_output=True,
                text=True,
                timeout=5
            )

            if result.returncode == 0:
                # Parse service information
                lines = result.stdout.strip().split('\n')
                for line in lines:
                    if "SERVICE_NAME:" in line:
                        service_name = line.split("SERVICE_NAME:")[1].strip()
                        event = BehaviorEvent(
                            timestamp=time.time(),
                            behavior_type=BehaviorType.SYSTEM_OPERATION,
                            operation="ServiceAccess",
                            target=service_name,
                            threat_level=ThreatLevel.LOW,
                            description=f"Service access: {service_name}"
                        )
                        self.events.append(event)

        except Exception as e:
            self.logger.debug(f"System operation monitoring failed: {e}")

    def _monitor_crypto_operations(self):
        """Monitor cryptographic operations"""

        try:
            # This is a simplified implementation
            # In a real implementation, you would use crypto monitoring tools

            # Check for crypto-related processes
            result = subprocess.run(
                ["tasklist", "/fi", "imagename eq *crypto*"],
                capture_output=True,
                text=True,
                timeout=5
            )

            if result.returncode == 0:
                # Parse crypto process information
                lines = result.stdout.strip().split('\n')
                for line in lines[2:]:  # Skip header lines
                    if line.strip():
                        parts = line.split()
                        if len(parts) >= 2:
                            process_name = parts[0]
                            process_id = parts[1]

                            event = BehaviorEvent(
                                timestamp=time.time(),
                                behavior_type=BehaviorType.CRYPTO_OPERATION,
                                operation="CryptoProcess",
                                target=process_name,
                                process_id=int(process_id),
                                threat_level=ThreatLevel.MEDIUM,
                                description=f"Crypto process: {process_name}"
                            )
                            self.events.append(event)

        except Exception as e:
            self.logger.debug(f"Crypto operation monitoring failed: {e}")

    def _monitor_anti_analysis(self):
        """Monitor anti-analysis techniques"""

        try:
            # This is a simplified implementation
            # In a real implementation, you would use anti-analysis monitoring tools

            # Check for debugger processes
            result = subprocess.run(
                ["tasklist", "/fi", "imagename eq *debug*"],
                capture_output=True,
                text=True,
                timeout=5
            )

            if result.returncode == 0:
                # Parse debugger process information
                lines = result.stdout.strip().split('\n')
                for line in lines[2:]:  # Skip header lines
                    if line.strip():
                        parts = line.split()
                        if len(parts) >= 2:
                            process_name = parts[0]
                            process_id = parts[1]

                            event = BehaviorEvent(
                                timestamp=time.time(),
                                behavior_type=BehaviorType.ANTI_ANALYSIS,
                                operation="DebuggerDetection",
                                target=process_name,
                                process_id=int(process_id),
                                threat_level=ThreatLevel.HIGH,
                                description=f"Debugger process detected: {process_name}"
                            )
                            self.events.append(event)

        except Exception as e:
            self.logger.debug(f"Anti-analysis monitoring failed: {e}")

    def _create_behavioral_profile(self) -> BehavioralProfile:
        """Create behavioral profile from captured events"""

        try:
            # Calculate analysis duration
            analysis_duration = time.time() - self.start_time

            # Count behavior types
            behavior_types = {}
            for event in self.events:
                behavior_type = event.behavior_type
                if behavior_type not in behavior_types:
                    behavior_types[behavior_type] = 0
                behavior_types[behavior_type] += 1

            # Identify threat indicators
            threat_indicators = []
            for event in self.events:
                for indicator_type, patterns in self.threat_indicators.items():
                    if any(pattern in event.operation for pattern in patterns):
                        threat_indicators.append(f"{indicator_type}: {event.operation}")

            # Identify suspicious operations
            suspicious_operations = [
                event for event in self.events
                if event.threat_level in [ThreatLevel.HIGH, ThreatLevel.CRITICAL]
            ]

            # Categorize operations
            network_connections = [
                {
                    "timestamp": event.timestamp,
                    "operation": event.operation,
                    "target": event.target,
                    "threat_level": event.threat_level.value
                }
                for event in self.events
                if event.behavior_type == BehaviorType.NETWORK_OPERATION
            ]

            file_operations = [
                {
                    "timestamp": event.timestamp,
                    "operation": event.operation,
                    "target": event.target,
                    "threat_level": event.threat_level.value
                }
                for event in self.events
                if event.behavior_type == BehaviorType.FILE_OPERATION
            ]

            registry_operations = [
                {
                    "timestamp": event.timestamp,
                    "operation": event.operation,
                    "target": event.target,
                    "threat_level": event.threat_level.value
                }
                for event in self.events
                if event.behavior_type == BehaviorType.REGISTRY_OPERATION
            ]

            process_operations = [
                {
                    "timestamp": event.timestamp,
                    "operation": event.operation,
                    "target": event.target,
                    "threat_level": event.threat_level.value
                }
                for event in self.events
                if event.behavior_type == BehaviorType.PROCESS_OPERATION
            ]

            # Calculate risk score
            risk_score = self._calculate_risk_score(self.events)

            # Determine threat level
            threat_level = self._determine_threat_level(risk_score)

            # Create behavioral profile
            profile = BehavioralProfile(
                binary_path="",  # Will be set by caller
                analysis_duration=analysis_duration,
                total_events=len(self.events),
                behavior_types=behavior_types,
                threat_indicators=threat_indicators,
                suspicious_operations=suspicious_operations,
                network_connections=network_connections,
                file_operations=file_operations,
                registry_operations=registry_operations,
                process_operations=process_operations,
                risk_score=risk_score,
                threat_level=threat_level
            )

            return profile

        except Exception as e:
            self.logger.error(f"Failed to create behavioral profile: {e}")
            return None

    def _calculate_risk_score(self, events: List[BehaviorEvent]) -> float:
        """Calculate risk score from behavioral events"""

        try:
            risk_score = 0.0

            # Base score from threat levels
            for event in events:
                if event.threat_level == ThreatLevel.MINIMAL:
                    risk_score += 0.1
                elif event.threat_level == ThreatLevel.LOW:
                    risk_score += 0.5
                elif event.threat_level == ThreatLevel.MEDIUM:
                    risk_score += 1.0
                elif event.threat_level == ThreatLevel.HIGH:
                    risk_score += 2.0
                elif event.threat_level == ThreatLevel.CRITICAL:
                    risk_score += 5.0

            # Additional score from behavior types
            behavior_type_scores = {
                BehaviorType.FILE_OPERATION: 0.1,
                BehaviorType.REGISTRY_OPERATION: 0.2,
                BehaviorType.NETWORK_OPERATION: 0.5,
                BehaviorType.PROCESS_OPERATION: 0.3,
                BehaviorType.MEMORY_OPERATION: 0.2,
                BehaviorType.SYSTEM_OPERATION: 0.4,
                BehaviorType.CRYPTO_OPERATION: 0.3,
                BehaviorType.ANTI_ANALYSIS: 1.0
            }

            for event in events:
                risk_score += behavior_type_scores.get(event.behavior_type, 0.0)

            # Normalize to 0-100 scale
            return min(risk_score, 100.0)

        except Exception as e:
            self.logger.error(f"Failed to calculate risk score: {e}")
            return 0.0

    def _determine_threat_level(self, risk_score: float) -> ThreatLevel:
        """Determine threat level from risk score"""

        if risk_score >= 80.0:
            return ThreatLevel.CRITICAL
        elif risk_score >= 60.0:
            return ThreatLevel.HIGH
        elif risk_score >= 40.0:
            return ThreatLevel.MEDIUM
        elif risk_score >= 20.0:
            return ThreatLevel.LOW
        else:
            return ThreatLevel.MINIMAL

    def save_behavioral_profile(self, profile: BehavioralProfile, output_file: str) -> bool:
        """Save behavioral profile to file"""

        try:
            output_path = Path(output_file)
            output_path.parent.mkdir(parents=True, exist_ok=True)

            # Convert profile to dictionary
            profile_dict = {
                "binary_path": profile.binary_path,
                "analysis_duration": profile.analysis_duration,
                "total_events": profile.total_events,
                "behavior_types": {bt.value: count for bt, count in profile.behavior_types.items()},
                "threat_indicators": profile.threat_indicators,
                "suspicious_operations": [
                    {
                        "timestamp": event.timestamp,
                        "behavior_type": event.behavior_type.value,
                        "operation": event.operation,
                        "target": event.target,
                        "threat_level": event.threat_level.value,
                        "description": event.description
                    }
                    for event in profile.suspicious_operations
                ],
                "network_connections": profile.network_connections,
                "file_operations": profile.file_operations,
                "registry_operations": profile.registry_operations,
                "process_operations": profile.process_operations,
                "risk_score": profile.risk_score,
                "threat_level": profile.threat_level.value
            }

            # Save to JSON file
            with open(output_path, 'w') as f:
                json.dump(profile_dict, f, indent=2, default=str)

            self.logger.info(f"Behavioral profile saved to: {output_file}")
            return True

        except Exception as e:
            self.logger.error(f"Failed to save behavioral profile: {e}")
            return False
