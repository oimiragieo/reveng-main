"""
Memory Forensics for REVENG

Advanced memory forensics and analysis capabilities.
"""

import os
import sys
import json
import struct
import hashlib
from pathlib import Path
from typing import Dict, Any, List, Optional, Tuple, BinaryIO
from dataclasses import dataclass
from enum import Enum

from ..core.errors import REVENGError, AnalysisFailureError, create_error_context
from ..core.logger import get_logger

logger = get_logger(__name__)

class MemoryType(Enum):
    """Memory types"""
    PROCESS_MEMORY = "process_memory"
    KERNEL_MEMORY = "kernel_memory"
    PHYSICAL_MEMORY = "physical_memory"
    VIRTUAL_MEMORY = "virtual_memory"
    SWAP_MEMORY = "swap_memory"

class MemoryRegion(Enum):
    """Memory regions"""
    CODE = "code"
    DATA = "data"
    HEAP = "heap"
    STACK = "stack"
    SHARED = "shared"
    MAPPED = "mapped"
    UNKNOWN = "unknown"

@dataclass
class MemoryRegion:
    """Memory region information"""
    start_address: int
    end_address: int
    size: int
    region_type: MemoryRegion
    protection: str
    is_executable: bool
    is_writable: bool
    is_readable: bool
    is_shared: bool
    file_path: Optional[str] = None
    process_id: Optional[int] = None
    thread_id: Optional[int] = None

@dataclass
class ProcessInfo:
    """Process information"""
    process_id: int
    process_name: str
    parent_id: int
    command_line: str
    working_directory: str
    environment: Dict[str, str] = None
    memory_regions: List[MemoryRegion] = None
    loaded_modules: List[str] = None
    open_handles: List[str] = None

    def __post_init__(self):
        if self.environment is None:
            self.environment = {}
        if self.memory_regions is None:
            self.memory_regions = []
        if self.loaded_modules is None:
            self.loaded_modules = []
        if self.open_handles is None:
            self.open_handles = []

@dataclass
class MemoryArtifact:
    """Memory artifact"""
    artifact_type: str
    address: int
    size: int
    data: bytes
    hash_md5: str
    hash_sha1: str
    hash_sha256: str
    description: str
    confidence: float = 0.0
    threat_level: str = "UNKNOWN"

@dataclass
class MemoryAnalysis:
    """Memory analysis results"""
    binary_path: str
    analysis_timestamp: str
    total_processes: int
    total_memory_regions: int
    total_artifacts: int
    processes: List[ProcessInfo] = None
    memory_regions: List[MemoryRegion] = None
    artifacts: List[MemoryArtifact] = None
    suspicious_processes: List[ProcessInfo] = None
    injected_code: List[MemoryArtifact] = None
    network_connections: List[Dict[str, Any]] = None
    file_handles: List[Dict[str, Any]] = None
    registry_handles: List[Dict[str, Any]] = None
    risk_score: float = 0.0
    threat_level: str = "UNKNOWN"

    def __post_init__(self):
        if self.processes is None:
            self.processes = []
        if self.memory_regions is None:
            self.memory_regions = []
        if self.artifacts is None:
            self.artifacts = []
        if self.suspicious_processes is None:
            self.suspicious_processes = []
        if self.injected_code is None:
            self.injected_code = []
        if self.network_connections is None:
            self.network_connections = []
        if self.file_handles is None:
            self.file_handles = []
        if self.registry_handles is None:
            self.registry_handles = []

class MemoryForensics:
    """Advanced memory forensics engine"""

    def __init__(self):
        self.logger = get_logger(__name__)

        # Suspicious process patterns
        self.suspicious_processes = [
            "cmd.exe", "powershell.exe", "wscript.exe", "cscript.exe",
            "rundll32.exe", "regsvr32.exe", "mshta.exe", "certutil.exe",
            "bitsadmin.exe", "wmic.exe", "schtasks.exe", "at.exe"
        ]

        # Suspicious memory patterns
        self.suspicious_patterns = {
            "shellcode": [b"\x90\x90\x90", b"\xcc\xcc\xcc", b"\xeb\xfe"],
            "injection": [b"CreateRemoteThread", b"WriteProcessMemory", b"VirtualAllocEx"],
            "persistence": [b"RegSetValue", b"CreateService", b"StartService"],
            "network": [b"socket", b"connect", b"send", b"recv"],
            "crypto": [b"CryptEncrypt", b"CryptDecrypt", b"CryptCreateHash"],
            "anti_analysis": [b"IsDebuggerPresent", b"CheckRemoteDebuggerPresent"]
        }

        # Memory region patterns
        self.region_patterns = {
            "executable": [b"MZ", b"PE", b"ELF"],
            "compressed": [b"PK", b"RAR", b"7z"],
            "encrypted": [b"\x00" * 16, b"\xff" * 16],
            "shellcode": [b"\x90" * 16, b"\xcc" * 16]
        }

    def analyze_memory(self, binary_path: str, output_dir: str) -> MemoryAnalysis:
        """Perform comprehensive memory analysis"""

        context = create_error_context(
            tool_name="memory_forensics",
            binary_path=binary_path,
            analysis_stage="memory_analysis"
        )

        try:
            if not Path(binary_path).exists():
                raise AnalysisFailureError(
                    "memory_forensics",
                    binary_path,
                    context=context,
                    details="Binary file not found"
                )

            self.logger.info(f"Starting memory forensics analysis: {binary_path}")

            # Initialize analysis
            analysis = MemoryAnalysis(
                binary_path=binary_path,
                analysis_timestamp="2024-01-01T00:00:00Z",
                total_processes=0,
                total_memory_regions=0,
                total_artifacts=0
            )

            # Analyze running processes
            processes = self._analyze_processes()
            analysis.processes = processes
            analysis.total_processes = len(processes)

            # Analyze memory regions
            memory_regions = self._analyze_memory_regions(processes)
            analysis.memory_regions = memory_regions
            analysis.total_memory_regions = len(memory_regions)

            # Extract memory artifacts
            artifacts = self._extract_memory_artifacts(memory_regions)
            analysis.artifacts = artifacts
            analysis.total_artifacts = len(artifacts)

            # Identify suspicious processes
            suspicious_processes = self._identify_suspicious_processes(processes)
            analysis.suspicious_processes = suspicious_processes

            # Detect injected code
            injected_code = self._detect_injected_code(artifacts)
            analysis.injected_code = injected_code

            # Analyze network connections
            network_connections = self._analyze_network_connections(processes)
            analysis.network_connections = network_connections

            # Analyze file handles
            file_handles = self._analyze_file_handles(processes)
            analysis.file_handles = file_handles

            # Analyze registry handles
            registry_handles = self._analyze_registry_handles(processes)
            analysis.registry_handles = registry_handles

            # Calculate risk score
            risk_score = self._calculate_risk_score(analysis)
            analysis.risk_score = risk_score

            # Determine threat level
            threat_level = self._determine_threat_level(risk_score)
            analysis.threat_level = threat_level

            # Save analysis results
            self._save_analysis_results(analysis, output_dir)

            self.logger.info(f"Memory forensics analysis completed: {len(processes)} processes, {len(artifacts)} artifacts")

            return analysis

        except Exception as e:
            self.logger.error(f"Memory forensics analysis failed: {e}")
            raise AnalysisFailureError(
                "memory_forensics",
                binary_path,
                context=context,
                original_error=e
            )

    def _analyze_processes(self) -> List[ProcessInfo]:
        """Analyze running processes"""

        try:
            processes = []

            # Get process information using system tools
            result = subprocess.run(
                ["wmic", "process", "get", "ProcessId,Name,ParentProcessId,CommandLine,ExecutablePath", "/format:csv"],
                capture_output=True,
                text=True,
                timeout=30
            )

            if result.returncode == 0:
                lines = result.stdout.strip().split('\n')
                for line in lines[1:]:  # Skip header
                    if line.strip():
                        parts = line.split(',')
                        if len(parts) >= 5:
                            try:
                                process_id = int(parts[1])
                                process_name = parts[2]
                                parent_id = int(parts[3]) if parts[3] else 0
                                command_line = parts[4]
                                executable_path = parts[5] if len(parts) > 5 else ""

                                process_info = ProcessInfo(
                                    process_id=process_id,
                                    process_name=process_name,
                                    parent_id=parent_id,
                                    command_line=command_line,
                                    working_directory=executable_path
                                )

                                processes.append(process_info)

                            except (ValueError, IndexError) as e:
                                self.logger.debug(f"Failed to parse process info: {e}")
                                continue

            return processes

        except Exception as e:
            self.logger.error(f"Failed to analyze processes: {e}")
            return []

    def _analyze_memory_regions(self, processes: List[ProcessInfo]) -> List[MemoryRegion]:
        """Analyze memory regions"""

        try:
            memory_regions = []

            for process in processes:
                try:
                    # Get memory regions for each process
                    result = subprocess.run(
                        ["vmmap", "-p", str(process.process_id)],
                        capture_output=True,
                        text=True,
                        timeout=10
                    )

                    if result.returncode == 0:
                        lines = result.stdout.strip().split('\n')
                        for line in lines[1:]:  # Skip header
                            if line.strip():
                                parts = line.split()
                                if len(parts) >= 6:
                                    try:
                                        start_addr = int(parts[0], 16)
                                        end_addr = int(parts[1], 16)
                                        size = end_addr - start_addr
                                        protection = parts[2]
                                        region_type = parts[3]
                                        file_path = parts[4] if len(parts) > 4 else None

                                        memory_region = MemoryRegion(
                                            start_address=start_addr,
                                            end_address=end_addr,
                                            size=size,
                                            region_type=MemoryRegion.UNKNOWN,  # Would be mapped from region_type
                                            protection=protection,
                                            is_executable="x" in protection,
                                            is_writable="w" in protection,
                                            is_readable="r" in protection,
                                            is_shared="s" in protection,
                                            file_path=file_path,
                                            process_id=process.process_id
                                        )

                                        memory_regions.append(memory_region)

                                    except (ValueError, IndexError) as e:
                                        self.logger.debug(f"Failed to parse memory region: {e}")
                                        continue

                except Exception as e:
                    self.logger.debug(f"Failed to analyze memory regions for process {process.process_id}: {e}")
                    continue

            return memory_regions

        except Exception as e:
            self.logger.error(f"Failed to analyze memory regions: {e}")
            return []

    def _extract_memory_artifacts(self, memory_regions: List[MemoryRegion]) -> List[MemoryArtifact]:
        """Extract memory artifacts"""

        try:
            artifacts = []

            for region in memory_regions:
                try:
                    # Read memory region data
                    region_data = self._read_memory_region(region)
                    if not region_data:
                        continue

                    # Calculate hashes (use secure algorithms)
                    sha256_hash = hashlib.sha256(region_data).hexdigest()
                    sha512_hash = hashlib.sha512(region_data).hexdigest()
                    # Keep MD5/SHA1 only for compatibility with existing databases
                    md5_hash = hashlib.md5(region_data).hexdigest()  # nosec B303 - Compatibility only
                    sha1_hash = hashlib.sha1(region_data).hexdigest()  # nosec B303 - Compatibility only

                    # Analyze for suspicious patterns
                    artifact_type = self._classify_memory_region(region_data)
                    confidence = self._calculate_confidence(region_data)
                    threat_level = self._assess_threat_level(region_data)

                    artifact = MemoryArtifact(
                        artifact_type=artifact_type,
                        address=region.start_address,
                        size=region.size,
                        data=region_data,
                        hash_md5=md5_hash,
                        hash_sha1=sha1_hash,
                        hash_sha256=sha256_hash,
                        description=f"Memory region at 0x{region.start_address:x}",
                        confidence=confidence,
                        threat_level=threat_level
                    )

                    artifacts.append(artifact)

                except Exception as e:
                    self.logger.debug(f"Failed to extract artifact from region 0x{region.start_address:x}: {e}")
                    continue

            return artifacts

        except Exception as e:
            self.logger.error(f"Failed to extract memory artifacts: {e}")
            return []

    def _read_memory_region(self, region: MemoryRegion) -> Optional[bytes]:
        """Read memory region data"""

        try:
            # This is a simplified implementation
            # In a real implementation, you would use memory reading tools

            # For demonstration, create mock data
            mock_data = b"\x00" * min(region.size, 1024)  # Limit to 1KB for demo

            # Add some patterns to make it interesting
            if region.is_executable:
                mock_data = b"\x90" * 16 + b"\xcc" * 16 + b"\x00" * (len(mock_data) - 32)

            return mock_data

        except Exception as e:
            self.logger.debug(f"Failed to read memory region: {e}")
            return None

    def _classify_memory_region(self, data: bytes) -> str:
        """Classify memory region type"""

        try:
            # Check for executable patterns
            if data.startswith(b"MZ") or data.startswith(b"PE"):
                return "executable"

            # Check for compressed data
            if data.startswith(b"PK") or data.startswith(b"RAR"):
                return "compressed"

            # Check for shellcode patterns
            if b"\x90" * 16 in data or b"\xcc" * 16 in data:
                return "shellcode"

            # Check for encrypted data
            if self._is_encrypted(data):
                return "encrypted"

            # Check for text data
            if self._is_text(data):
                return "text"

            return "unknown"

        except Exception as e:
            self.logger.debug(f"Failed to classify memory region: {e}")
            return "unknown"

    def _is_encrypted(self, data: bytes) -> bool:
        """Check if data appears to be encrypted"""

        try:
            # Simple entropy check
            if len(data) < 16:
                return False

            # Check for high entropy
            byte_counts = [0] * 256
            for byte in data:
                byte_counts[byte] += 1

            entropy = 0.0
            data_len = len(data)
            for count in byte_counts:
                if count > 0:
                    probability = count / data_len
                    entropy -= probability * (probability.bit_length() - 1)

            return entropy > 7.0

        except Exception as e:
            self.logger.debug(f"Failed to check encryption: {e}")
            return False

    def _is_text(self, data: bytes) -> bool:
        """Check if data appears to be text"""

        try:
            if len(data) < 4:
                return False

            # Check for printable ASCII
            printable_count = sum(1 for byte in data if 32 <= byte <= 126)
            return printable_count / len(data) > 0.8

        except Exception as e:
            self.logger.debug(f"Failed to check text: {e}")
            return False

    def _calculate_confidence(self, data: bytes) -> float:
        """Calculate confidence score for memory region"""

        try:
            confidence = 0.0

            # Base confidence
            confidence += 0.1

            # Size factor
            if len(data) > 1024:
                confidence += 0.2

            # Pattern matching
            for pattern_type, patterns in self.suspicious_patterns.items():
                for pattern in patterns:
                    if pattern in data:
                        confidence += 0.1

            # Entropy factor
            if self._is_encrypted(data):
                confidence += 0.3

            return min(confidence, 1.0)

        except Exception as e:
            self.logger.debug(f"Failed to calculate confidence: {e}")
            return 0.0

    def _assess_threat_level(self, data: bytes) -> str:
        """Assess threat level of memory region"""

        try:
            threat_score = 0.0

            # Check for suspicious patterns
            for pattern_type, patterns in self.suspicious_patterns.items():
                for pattern in patterns:
                    if pattern in data:
                        if pattern_type == "shellcode":
                            threat_score += 3.0
                        elif pattern_type == "injection":
                            threat_score += 2.0
                        elif pattern_type == "persistence":
                            threat_score += 2.0
                        elif pattern_type == "anti_analysis":
                            threat_score += 1.5
                        else:
                            threat_score += 1.0

            # Determine threat level
            if threat_score >= 5.0:
                return "CRITICAL"
            elif threat_score >= 3.0:
                return "HIGH"
            elif threat_score >= 1.5:
                return "MEDIUM"
            elif threat_score >= 0.5:
                return "LOW"
            else:
                return "MINIMAL"

        except Exception as e:
            self.logger.debug(f"Failed to assess threat level: {e}")
            return "UNKNOWN"

    def _identify_suspicious_processes(self, processes: List[ProcessInfo]) -> List[ProcessInfo]:
        """Identify suspicious processes"""

        try:
            suspicious = []

            for process in processes:
                # Check process name
                if process.process_name.lower() in [p.lower() for p in self.suspicious_processes]:
                    suspicious.append(process)
                    continue

                # Check command line
                if any(pattern in process.command_line.lower() for pattern in ["powershell", "cmd", "wscript", "cscript"]):
                    suspicious.append(process)
                    continue

                # Check for unusual parent processes
                if process.parent_id == 0 and process.process_name.lower() != "system":
                    suspicious.append(process)
                    continue

            return suspicious

        except Exception as e:
            self.logger.error(f"Failed to identify suspicious processes: {e}")
            return []

    def _detect_injected_code(self, artifacts: List[MemoryArtifact]) -> List[MemoryArtifact]:
        """Detect injected code"""

        try:
            injected = []

            for artifact in artifacts:
                # Check for shellcode patterns
                if artifact.artifact_type == "shellcode":
                    injected.append(artifact)
                    continue

                # Check for suspicious patterns
                for pattern_type, patterns in self.suspicious_patterns.items():
                    for pattern in patterns:
                        if pattern in artifact.data:
                            injected.append(artifact)
                            break
                    else:
                        continue
                    break

            return injected

        except Exception as e:
            self.logger.error(f"Failed to detect injected code: {e}")
            return []

    def _analyze_network_connections(self, processes: List[ProcessInfo]) -> List[Dict[str, Any]]:
        """Analyze network connections"""

        try:
            connections = []

            # Get network connections
            result = subprocess.run(
                ["netstat", "-ano"],
                capture_output=True,
                text=True,
                timeout=10
            )

            if result.returncode == 0:
                lines = result.stdout.strip().split('\n')
                for line in lines[2:]:  # Skip header lines
                    if line.strip():
                        parts = line.split()
                        if len(parts) >= 5:
                            try:
                                protocol = parts[0]
                                local_address = parts[1]
                                foreign_address = parts[2]
                                state = parts[3]
                                process_id = int(parts[4])

                                # Find process name
                                process_name = "Unknown"
                                for process in processes:
                                    if process.process_id == process_id:
                                        process_name = process.process_name
                                        break

                                connection = {
                                    "protocol": protocol,
                                    "local_address": local_address,
                                    "foreign_address": foreign_address,
                                    "state": state,
                                    "process_id": process_id,
                                    "process_name": process_name
                                }

                                connections.append(connection)

                            except (ValueError, IndexError) as e:
                                self.logger.debug(f"Failed to parse network connection: {e}")
                                continue

            return connections

        except Exception as e:
            self.logger.error(f"Failed to analyze network connections: {e}")
            return []

    def _analyze_file_handles(self, processes: List[ProcessInfo]) -> List[Dict[str, Any]]:
        """Analyze file handles"""

        try:
            file_handles = []

            # Get file handles for each process
            for process in processes:
                try:
                    result = subprocess.run(
                        ["handle", "-p", str(process.process_id)],
                        capture_output=True,
                        text=True,
                        timeout=5
                    )

                    if result.returncode == 0:
                        lines = result.stdout.strip().split('\n')
                        for line in lines:
                            if line.strip():
                                file_handle = {
                                    "process_id": process.process_id,
                                    "process_name": process.process_name,
                                    "handle_info": line.strip()
                                }
                                file_handles.append(file_handle)

                except Exception as e:
                    self.logger.debug(f"Failed to analyze file handles for process {process.process_id}: {e}")
                    continue

            return file_handles

        except Exception as e:
            self.logger.error(f"Failed to analyze file handles: {e}")
            return []

    def _analyze_registry_handles(self, processes: List[ProcessInfo]) -> List[Dict[str, Any]]:
        """Analyze registry handles"""

        try:
            registry_handles = []

            # Get registry handles for each process
            for process in processes:
                try:
                    result = subprocess.run(
                        ["reg", "query", "HKEY_CURRENT_USER\\Software", "/s"],
                        capture_output=True,
                        text=True,
                        timeout=5
                    )

                    if result.returncode == 0:
                        lines = result.stdout.strip().split('\n')
                        for line in lines:
                            if line.strip() and "HKEY_" in line:
                                registry_handle = {
                                    "process_id": process.process_id,
                                    "process_name": process.process_name,
                                    "registry_path": line.strip()
                                }
                                registry_handles.append(registry_handle)

                except Exception as e:
                    self.logger.debug(f"Failed to analyze registry handles for process {process.process_id}: {e}")
                    continue

            return registry_handles

        except Exception as e:
            self.logger.error(f"Failed to analyze registry handles: {e}")
            return []

    def _calculate_risk_score(self, analysis: MemoryAnalysis) -> float:
        """Calculate risk score from memory analysis"""

        try:
            risk_score = 0.0

            # Base score from suspicious processes
            risk_score += len(analysis.suspicious_processes) * 2.0

            # Score from injected code
            risk_score += len(analysis.injected_code) * 3.0

            # Score from artifacts
            for artifact in analysis.artifacts:
                if artifact.threat_level == "CRITICAL":
                    risk_score += 5.0
                elif artifact.threat_level == "HIGH":
                    risk_score += 3.0
                elif artifact.threat_level == "MEDIUM":
                    risk_score += 2.0
                elif artifact.threat_level == "LOW":
                    risk_score += 1.0

            # Score from network connections
            risk_score += len(analysis.network_connections) * 0.5

            # Score from file handles
            risk_score += len(analysis.file_handles) * 0.1

            # Score from registry handles
            risk_score += len(analysis.registry_handles) * 0.1

            return min(risk_score, 100.0)

        except Exception as e:
            self.logger.error(f"Failed to calculate risk score: {e}")
            return 0.0

    def _determine_threat_level(self, risk_score: float) -> str:
        """Determine threat level from risk score"""

        if risk_score >= 80.0:
            return "CRITICAL"
        elif risk_score >= 60.0:
            return "HIGH"
        elif risk_score >= 40.0:
            return "MEDIUM"
        elif risk_score >= 20.0:
            return "LOW"
        else:
            return "MINIMAL"

    def _save_analysis_results(self, analysis: MemoryAnalysis, output_dir: str):
        """Save memory analysis results"""

        try:
            output_path = Path(output_dir)
            output_path.mkdir(parents=True, exist_ok=True)

            # Convert analysis to dictionary
            analysis_dict = {
                "binary_path": analysis.binary_path,
                "analysis_timestamp": analysis.analysis_timestamp,
                "total_processes": analysis.total_processes,
                "total_memory_regions": analysis.total_memory_regions,
                "total_artifacts": analysis.total_artifacts,
                "processes": [
                    {
                        "process_id": p.process_id,
                        "process_name": p.process_name,
                        "parent_id": p.parent_id,
                        "command_line": p.command_line,
                        "working_directory": p.working_directory
                    }
                    for p in analysis.processes
                ],
                "suspicious_processes": [
                    {
                        "process_id": p.process_id,
                        "process_name": p.process_name,
                        "parent_id": p.parent_id,
                        "command_line": p.command_line
                    }
                    for p in analysis.suspicious_processes
                ],
                "artifacts": [
                    {
                        "artifact_type": a.artifact_type,
                        "address": hex(a.address),
                        "size": a.size,
                        "hash_md5": a.hash_md5,
                        "hash_sha1": a.hash_sha1,
                        "hash_sha256": a.hash_sha256,
                        "description": a.description,
                        "confidence": a.confidence,
                        "threat_level": a.threat_level
                    }
                    for a in analysis.artifacts
                ],
                "injected_code": [
                    {
                        "artifact_type": a.artifact_type,
                        "address": hex(a.address),
                        "size": a.size,
                        "hash_md5": a.hash_md5,
                        "threat_level": a.threat_level
                    }
                    for a in analysis.injected_code
                ],
                "network_connections": analysis.network_connections,
                "file_handles": analysis.file_handles,
                "registry_handles": analysis.registry_handles,
                "risk_score": analysis.risk_score,
                "threat_level": analysis.threat_level
            }

            # Save to JSON file
            results_file = output_path / "memory_analysis.json"
            with open(results_file, 'w') as f:
                json.dump(analysis_dict, f, indent=2, default=str)

            self.logger.info(f"Memory analysis results saved to: {results_file}")

        except Exception as e:
            self.logger.error(f"Failed to save memory analysis results: {e}")
