#!/usr/bin/env python3
"""
Vulnerability Dataset Loader
===========================

Loads and processes vulnerability datasets for ML training.
Supports CVE data, synthetic samples, and real-world vulnerability examples.

Author: REVENG Project - AI Enhancement Module
Version: 1.0
"""

import json
import logging
import requests
import re
from typing import Dict, List, Tuple, Any, Optional
from pathlib import Path
from dataclasses import dataclass
import time

@dataclass
class VulnerabilityRecord:
    """Represents a vulnerability record for training"""
    cve_id: str
    description: str
    code_sample: str
    language: str
    vulnerability_type: str
    severity: str
    is_vulnerable: bool
    source: str
    metadata: Dict[str, Any]


class VulnerabilityDatasetLoader:
    """Loads vulnerability datasets from various sources"""
    
    def __init__(self, cache_dir: str = "models/datasets"):
        self.logger = logging.getLogger(__name__)
        self.cache_dir = Path(cache_dir)
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # Vulnerability type mappings
        self.vuln_type_mapping = {
            'buffer overflow': 'buffer_overflow',
            'buffer overrun': 'buffer_overflow',
            'stack overflow': 'buffer_overflow',
            'heap overflow': 'buffer_overflow',
            'sql injection': 'injection',
            'code injection': 'injection',
            'command injection': 'injection',
            'xss': 'injection',
            'cross-site scripting': 'injection',
            'memory leak': 'memory_corruption',
            'use after free': 'memory_corruption',
            'double free': 'memory_corruption',
            'null pointer dereference': 'memory_corruption',
            'format string': 'injection',
            'path traversal': 'injection',
            'directory traversal': 'injection'
        }
    
    def load_cve_dataset(self, limit: int = 100) -> List[VulnerabilityRecord]:
        """Load CVE vulnerability data"""
        cache_file = self.cache_dir / "cve_dataset.json"
        
        # Try to load from cache first
        if cache_file.exists():
            try:
                with open(cache_file, 'r') as f:
                    cached_data = json.load(f)
                self.logger.info(f"Loaded {len(cached_data)} CVE records from cache")
                return [VulnerabilityRecord(**record) for record in cached_data]
            except Exception as e:
                self.logger.warning(f"Failed to load cached CVE data: {e}")
        
        # Generate synthetic CVE-like data (since real CVE API access is complex)
        records = self._generate_cve_like_data(limit)
        
        # Cache the data
        try:
            with open(cache_file, 'w') as f:
                json.dump([record.__dict__ for record in records], f, indent=2)
            self.logger.info(f"Cached {len(records)} CVE records")
        except Exception as e:
            self.logger.warning(f"Failed to cache CVE data: {e}")
        
        return records
    
    def _generate_cve_like_data(self, limit: int) -> List[VulnerabilityRecord]:
        """Generate CVE-like vulnerability data for training"""
        records = []
        
        # Buffer overflow CVEs
        buffer_overflow_samples = [
            {
                'cve_id': 'CVE-2021-44228',
                'description': 'Buffer overflow in string handling function',
                'code': '''
                void vulnerable_strcpy(char *input) {
                    char buffer[256];
                    strcpy(buffer, input);  // CVE-2021-44228 style vulnerability
                    process_buffer(buffer);
                }
                ''',
                'language': 'c',
                'vuln_type': 'buffer_overflow',
                'severity': 'critical'
            },
            {
                'cve_id': 'CVE-2020-1472',
                'description': 'Stack buffer overflow in network protocol handler',
                'code': '''
                int handle_network_packet(char *packet, int len) {
                    char local_buffer[512];
                    memcpy(local_buffer, packet, len);  // No bounds checking
                    return parse_packet(local_buffer);
                }
                ''',
                'language': 'c',
                'vuln_type': 'buffer_overflow',
                'severity': 'high'
            }
        ]
        
        # Injection CVEs
        injection_samples = [
            {
                'cve_id': 'CVE-2019-11510',
                'description': 'SQL injection in user authentication',
                'code': '''
                def authenticate_user(username, password):
                    query = f"SELECT * FROM users WHERE username='{username}' AND password='{password}'"
                    return execute_query(query)  # SQL injection vulnerability
                ''',
                'language': 'python',
                'vuln_type': 'injection',
                'severity': 'high'
            },
            {
                'cve_id': 'CVE-2018-15473',
                'description': 'Command injection in file processing',
                'code': '''
                void process_file(char *filename) {
                    char command[1024];
                    sprintf(command, "cat %s | grep pattern", filename);
                    system(command);  // Command injection
                }
                ''',
                'language': 'c',
                'vuln_type': 'injection',
                'severity': 'medium'
            }
        ]
        
        # Memory corruption CVEs
        memory_samples = [
            {
                'cve_id': 'CVE-2017-5754',
                'description': 'Use-after-free in memory management',
                'code': '''
                void memory_handler() {
                    char *ptr = malloc(1024);
                    process_data(ptr);
                    free(ptr);
                    
                    if (error_condition) {
                        log_error(ptr);  // Use after free
                    }
                }
                ''',
                'language': 'c',
                'vuln_type': 'memory_corruption',
                'severity': 'high'
            }
        ]
        
        # Safe code examples
        safe_samples = [
            {
                'cve_id': 'SAFE-001',
                'description': 'Properly bounds-checked string operation',
                'code': '''
                void safe_strcpy(char *input, size_t input_len) {
                    char buffer[256];
                    if (input_len >= sizeof(buffer)) {
                        return;  // Proper bounds checking
                    }
                    strncpy(buffer, input, sizeof(buffer) - 1);
                    buffer[sizeof(buffer) - 1] = '\\0';
                    process_buffer(buffer);
                }
                ''',
                'language': 'c',
                'vuln_type': 'safe',
                'severity': 'info'
            },
            {
                'cve_id': 'SAFE-002',
                'description': 'Parameterized SQL query',
                'code': '''
                def safe_authenticate_user(username, password):
                    query = "SELECT * FROM users WHERE username=? AND password=?"
                    return execute_prepared_query(query, (username, password))
                ''',
                'language': 'python',
                'vuln_type': 'safe',
                'severity': 'info'
            }
        ]
        
        # Combine all samples
        all_samples = buffer_overflow_samples + injection_samples + memory_samples + safe_samples
        
        # Create records
        for sample in all_samples[:limit]:
            record = VulnerabilityRecord(
                cve_id=sample['cve_id'],
                description=sample['description'],
                code_sample=sample['code'],
                language=sample['language'],
                vulnerability_type=sample['vuln_type'],
                severity=sample['severity'],
                is_vulnerable=(sample['vuln_type'] != 'safe'),
                source='synthetic_cve',
                metadata={
                    'generated': True,
                    'category': sample['vuln_type']
                }
            )
            records.append(record)
        
        return records
    
    def load_real_world_samples(self) -> List[VulnerabilityRecord]:
        """Load real-world vulnerability samples"""
        records = []
        
        # Load from various sources
        samples_dir = self.cache_dir / "real_world_samples"
        if samples_dir.exists():
            for sample_file in samples_dir.glob("*.json"):
                try:
                    with open(sample_file, 'r') as f:
                        data = json.load(f)
                    
                    record = VulnerabilityRecord(
                        cve_id=data.get('id', 'UNKNOWN'),
                        description=data.get('description', ''),
                        code_sample=data.get('code', ''),
                        language=data.get('language', 'unknown'),
                        vulnerability_type=self._normalize_vuln_type(data.get('type', 'general')),
                        severity=data.get('severity', 'medium'),
                        is_vulnerable=data.get('vulnerable', True),
                        source='real_world',
                        metadata=data.get('metadata', {})
                    )
                    records.append(record)
                    
                except Exception as e:
                    self.logger.warning(f"Failed to load sample {sample_file}: {e}")
        
        return records
    
    def _normalize_vuln_type(self, vuln_type: str) -> str:
        """Normalize vulnerability type to standard categories"""
        vuln_type_lower = vuln_type.lower()
        
        for pattern, normalized in self.vuln_type_mapping.items():
            if pattern in vuln_type_lower:
                return normalized
        
        return 'general'
    
    def convert_to_training_format(self, records: List[VulnerabilityRecord]) -> List[Tuple[str, str, bool]]:
        """Convert vulnerability records to training format"""
        training_data = []
        
        for record in records:
            training_data.append((
                record.code_sample,
                record.language,
                record.is_vulnerable
            ))
        
        return training_data
    
    def get_comprehensive_dataset(self, cve_limit: int = 50) -> List[Tuple[str, str, bool]]:
        """Get comprehensive dataset combining all sources"""
        all_records = []
        
        # Load CVE data
        self.logger.info("Loading CVE dataset...")
        cve_records = self.load_cve_dataset(cve_limit)
        all_records.extend(cve_records)
        
        # Load real-world samples
        self.logger.info("Loading real-world samples...")
        real_world_records = self.load_real_world_samples()
        all_records.extend(real_world_records)
        
        self.logger.info(f"Loaded {len(all_records)} total vulnerability records")
        
        # Convert to training format
        return self.convert_to_training_format(all_records)
    
    def create_sample_dataset_file(self):
        """Create a sample dataset file for demonstration"""
        sample_file = self.cache_dir / "real_world_samples" / "sample_001.json"
        sample_file.parent.mkdir(parents=True, exist_ok=True)
        
        sample_data = {
            "id": "SAMPLE-001",
            "description": "Buffer overflow in network service",
            "code": '''
            void handle_request(char *request) {
                char buffer[1024];
                strcpy(buffer, request);  // Vulnerable
                process_request(buffer);
            }
            ''',
            "language": "c",
            "type": "buffer overflow",
            "severity": "high",
            "vulnerable": True,
            "metadata": {
                "source": "sample",
                "category": "network_service"
            }
        }
        
        with open(sample_file, 'w') as f:
            json.dump(sample_data, f, indent=2)
        
        self.logger.info(f"Created sample dataset file: {sample_file}")


def main():
    """Test the vulnerability dataset loader"""
    loader = VulnerabilityDatasetLoader()
    
    # Create sample dataset
    loader.create_sample_dataset_file()
    
    # Load comprehensive dataset
    dataset = loader.get_comprehensive_dataset()
    
    print(f"Loaded {len(dataset)} training samples")
    
    # Show sample data
    for i, (code, language, is_vulnerable) in enumerate(dataset[:5]):
        print(f"\nSample {i+1}:")
        print(f"Language: {language}")
        print(f"Vulnerable: {is_vulnerable}")
        print(f"Code preview: {code[:100]}...")


if __name__ == "__main__":
    main()